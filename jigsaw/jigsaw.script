local HELPER = require "jigsaw.helper"
local T = require "jigsaw.template"
local ZSTEP = 0.0000001

function init(self)
	msg.post(".", "acquire_input_focus")
	self.z = 0
	self.offset = vmath.vector3(0,0,0)
	self.children = {}
	self.parent = nil

	self.groups = {}
	for col = 1, #T.cells do
		for row = 1, #T.cells[col] do
			table.insert(self.groups, {go.get_id("part" .. col .. row)})
		end
	end
end

local function find_group(self, id)
	for i, g in ipairs(self.groups) do
		for _, part in ipairs(g) do
			if part == id then
				return g, i
			end
		end
	end
end

function final(self)
	msg.post(".", "release_input_focus")
end

function update(self, dt)
	if self.parent then -- we wait until next frame to set parent
		for _, id in ipairs(self.children) do
			go.set_parent(id, self.parent, true)
		end
		self.parent = nil
	end
end

local function check(drag_offset, col, row)
	if col < 1 or row < 1 or col > #T.cells or row > #T.cells[col] then
		return nil
	end
	
	local path = "part" .. col .. row
	local target = T.cells[col][row]
	local pos = go.get_world_position(path)
	local center = vmath.vector3(target.x * T.scale, target.y * T.scale, pos.z)
	local offset = pos - center

	if vmath.length(offset - drag_offset) <  T.distance * T.scale then
		return go.get_id(path), offset
	end
	return nil
end

local function get_cell(path)
	local url = msg.url()
	url.path = path
	url.fragment = "jigsaw_model"
	local row = go.get(url, "row")
	local col = go.get(url, "col")
	return T.cells[col][row], col, row
end

local function check_connections(self)
	local total = #self.drag
	local parent_center = nil
	local parent_offset = nil
	self.children = {}
	for i = 1, total do
		local cell, col, row = get_cell(self.drag[i])
		local pos = go.get_world_position(self.drag[i])
		local center = vmath.vector3(cell.x * T.scale, cell.y * T.scale, pos.z)
		local offset = pos - center
		parent_center = i == 1 and center or parent_center

		local coord_offsets = {{col - 1, row}, {col + 1, row}, {col, row + 1}, {col, row - 1}}
		for _, coord in ipairs(coord_offsets) do
			local other, other_offset = check(offset, coord[1], coord[2])
			if other then
				local g, idx = find_group(self, other)
				if g ~= self.drag then
					self.parent = self.drag[1]
					if parent_offset then
						cell  = get_cell(g[1])
						local other_center = vmath.vector3(cell.x * T.scale, cell.y * T.scale, pos.z)
						go.set_position(other_center + parent_offset, g[1])
					else
						go.set_position(parent_center + other_offset, self.drag[1])
						parent_offset = other_offset
					end
					
					for j, part in ipairs(g) do
						table.insert(self.drag, part)
						table.insert(self.children, part) --set parent on next frame
						local p = go.get_position(part)
						p.z = j == 1 and 1 or 0
						go.set_position(p, part)
					end
					table.remove(self.groups, idx)
				end
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") and message.enter then
		go.set_position(vmath.vector3(-10000, -10000, 0))
		if self.touch and not self.drag then
			self.drag = find_group(self, message.other_id)
			self.z = self.z + ZSTEP
			local pos = go.get_position(self.drag[1])
			--pos.z = self.z
			pos.z = 1
			self.offset = self.cursor - pos
			go.set_position(pos, self.drag[1])
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		self.cursor = HELPER.screen_to_world(action)
		go.set_position(self.cursor)
		self.touch = true
	elseif action_id == nil and self.drag then
		local p = HELPER.screen_to_world(action)
		go.set_position(p - self.offset, self.drag[1])
	elseif action_id == hash("touch") and action.released then
		if self.drag then
			local pos = go.get_position(self.drag[1])
			pos.z = self.z
			go.set_position(pos, self.drag[1])
			
			check_connections(self)
			self.drag = nil
		end
		self.touch = false
	end
end
